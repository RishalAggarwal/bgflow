
import pytest
import torch
import warnings
from bgtorch.distribution.energy.openmm import OpenMMEnergyBridge

def test_openmm_bridge_evaluate_dummy():
    """Test if we can evaluate an energy; skip test if openmm is not installed."""
    try:
        with warnings.catch_warnings():
            warnings.simplefilter("ignore", DeprecationWarning)  # ignore warnings inside OpenMM
            from simtk import openmm, unit
    except ImportError:
        pytest.skip("Test requires OpenMM.")

    # a system with one particle and an external dummy force
    system = openmm.System()
    system.addParticle(1.0 * unit.amu)
    force = openmm.CustomExternalForce("x")
    force.addParticle(0)
    system.addForce(force)

    # test forces and energies generated by the bridge
    bridge = OpenMMEnergyBridge(
        system,
        openmm.LangevinIntegrator,
        unit.nanometer,
        (300*unit.kelvin,1./unit.picoseconds, 1.*unit.femtoseconds)
    )
    positions = torch.tensor([[[0.1, 0.0, 0.0]]])
    kT = unit.MOLAR_GAS_CONSTANT_R * 300*unit.kelvin
    energies, forces = bridge.evaluate(positions, evaluate_energies=True, evaluate_forces=True)
    assert energies.numpy()[0] == pytest.approx([0.1*unit.kilojoule_per_mole/kT])
    assert forces.numpy()[0,0] == pytest.approx([-1.*unit.kilojoule_per_mole/kT,0.,0.], abs=1e-5, rel=0)


def test_openmm_bridge_evaluate_ala2():
    """Test if we can evaluate an energy; skip test if openmm is not installed."""
    try:
        with warnings.catch_warnings():
            warnings.simplefilter("ignore", DeprecationWarning)  # ignore warnings inside OpenMM
            from simtk import openmm, unit
            from openmmtools.testsystems import AlanineDipeptideImplicit
    except ImportError:
        pytest.skip("Test requires OpenMM and openmmtools.")

    # alanine dipeptide testsystem
    ala2 = AlanineDipeptideImplicit()
    system = ala2.system

    # test forces and energies generated by the bridge
    bridge = OpenMMEnergyBridge(
        system,
        openmm.LangevinIntegrator,
        unit.nanometer,
        (300*unit.kelvin,1./unit.picoseconds, 1.*unit.femtoseconds)
    )
    import numpy as np
    positions = torch.tensor(np.array([np.ravel(ala2.positions.value_in_unit(unit.nanometer))]))
    kT = unit.MOLAR_GAS_CONSTANT_R * 300*unit.kelvin
    energies, forces = bridge.evaluate(positions*1.0, evaluate_energies=True, evaluate_forces=True)
    print(forces)

    ctx = openmm.Context(system, openmm.LangevinIntegrator)
    ctx.setPositions(ala2.positions)
    f = ctx.getState(getForces=True).getForces()

    print(f)