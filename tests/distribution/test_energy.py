
import pytest
import torch
import warnings
from bgtorch.distribution.energy.openmm import OpenMMEnergyBridge, OpenMMEnergy


class OneParticleTestBridge(OpenMMEnergyBridge):
    """OpenMM bridge for a system with one particle"""
    def __init__(self, n_workers=1):
        try:
            with warnings.catch_warnings():
                warnings.simplefilter("ignore", DeprecationWarning)  # ignore warnings inside OpenMM
                from simtk import openmm, unit
        except ImportError:
            pytest.skip("Test requires OpenMM.")

        # a system with one particle and an external dummy force
        system = openmm.System()
        system.addParticle(1.0 * unit.amu)
        force = openmm.CustomExternalForce("x")
        force.addParticle(0)
        system.addForce(force)

        super(OneParticleTestBridge, self).__init__(
            system,
            openmm.LangevinIntegrator(300*unit.kelvin,1./unit.picoseconds, 1.*unit.femtoseconds),
            n_workers=n_workers
        )


@pytest.mark.parametrize("n_workers", [1,2,8])
def test_openmm_bridge_evaluate_dummy(n_workers):
    """Test if we can evaluate an energy; skip test if openmm is not installed."""

    bridge = OneParticleTestBridge(n_workers)

    from simtk import unit
    # test forces and energies generated by the bridge
    batch_size = 4
    positions = torch.tensor([[0.1, 0.0, 0.0]]*batch_size)
    kT = unit.MOLAR_GAS_CONSTANT_R * 300*unit.kelvin
    energies, forces = bridge.evaluate(positions)
    assert energies.shape == torch.Size([batch_size,1])
    assert forces.shape == torch.Size([batch_size, 3])
    assert energies.numpy()[0] == pytest.approx([0.1*unit.kilojoule_per_mole/kT])
    assert forces.numpy()[0] == pytest.approx([-1.*unit.kilojoule_per_mole/kT,0.,0.], abs=1e-5, rel=0)


def test_openmm_bridge_evaluate_ala2():
    """Test if we can evaluate an energy; skip test if openmm is not installed."""
    warnings.filterwarnings("ignore", category=RuntimeWarning, message="numpy.ufunc size changed")

    try:
        with warnings.catch_warnings():
            warnings.simplefilter("ignore", DeprecationWarning)  # ignore warnings inside OpenMM
            from simtk import openmm, unit
            from openmmtools.testsystems import AlanineDipeptideImplicit
    except ImportError:
        pytest.skip("Test requires OpenMM and openmmtools.")

    # alanine dipeptide testsystem
    ala2 = AlanineDipeptideImplicit()
    system = ala2.system

    # test forces and energies generated by the bridge
    bridge = OpenMMEnergyBridge(
        system,
        openmm.LangevinIntegrator(300*unit.kelvin,1./unit.picoseconds, 1.*unit.femtoseconds)
    )
    import numpy as np
    positions = torch.tensor(np.array([np.ravel(ala2.positions.value_in_unit(unit.nanometer))]))
    kT = unit.MOLAR_GAS_CONSTANT_R * 300*unit.kelvin
    energies, forces = bridge.evaluate(positions*1.0)
    assert energies.shape == torch.Size([1,1])
    assert forces.shape == torch.Size([1,66])


def test_openmm_bridge_cache():
    """Test if hashing and caching works."""
    bridge = OneParticleTestBridge()
    omm_energy = OpenMMEnergy(3, bridge)
    omm_energy._energy(torch.tensor([[0.1, 0.0, 0.0]]*2))
    hash1 = omm_energy._last_batch
    omm_energy._energy(torch.tensor([[0.2, 0.0, 0.0]]*2))
    assert omm_energy._last_batch != hash1
    omm_energy._energy(torch.tensor([[0.1, 0.0, 0.0]]*2))
    assert omm_energy._last_batch == hash1
    omm_energy._energy(torch.tensor([[0.1, 0.0, 0.0]]*2))

    # test if forces are in the same memory location for same input batch
    force_address = hex(id(omm_energy._openmm_energy_bridge.last_forces))
    force = omm_energy._openmm_energy_bridge.last_forces # retain a pointer to last forces so that memory is not freed
    assert hex(id(omm_energy.force(torch.tensor([[0.1, 0.0, 0.0]]*2)))) == force_address
    assert hex(id(omm_energy.force(torch.tensor([[0.1, 0.0, 0.0]]*2)))) == force_address
    assert hex(id(omm_energy.force(torch.tensor([[0.2, 0.0, 0.0]]*2)))) != force_address
    assert hex(id(omm_energy.force(torch.tensor([[0.1, 0.0, 0.0]]*2)))) != force_address
